#pragma config(Sensor, S1, sonarSensor, sensorEV3_Ultrasonic)
#pragma config(Sensor, S2, colorSensor, sensorEV3_Color)
#pragma config(Sensor, S3, gyroSensor, sensorEV3_Gyro)
#pragma config(Sensor, S4, contactSensor, sensorEV3_Touch)
#pragma config(Motor, motorA, motorGauche, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorD, motorDroit, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

const int DIST_OBSTACLE = 15;
const int VITESSE = 50;

// Tableau des virages : false = gauche, true = droite
bool virages[] = {
false, // 1. gauche
true, // 2. droite
true, // 3. droite
true, // 4. droite
true, // 5. droite
false, // 6. gauche
true // 7. droite
};

int indexVirage = 0;

void avancer() {
setMotorSpeed(motorGauche, VITESSE);
setMotorSpeed(motorDroit, VITESSE);
}

void stopRobot() {
setMotorSpeed(motorGauche, 0);
setMotorSpeed(motorDroit, 0);
}

void tourner90Degres(bool droite) {
resetGyro(gyroSensor);
int angleCible = droite ? 73 : -73;

if (droite) {
while (getGyroDegrees(gyroSensor) < angleCible) {
setMotorSpeed(motorGauche, VITESSE);
setMotorSpeed(motorDroit, -VITESSE);
}
} else {
while (getGyroDegrees(gyroSensor) > angleCible) {
setMotorSpeed(motorGauche, -VITESSE);
setMotorSpeed(motorDroit, VITESSE);
}
}

stopRobot();
wait1Msec(500);
}

void tourner360Degres() {
resetGyro(gyroSensor);
while (abs(getGyroDegrees(gyroSensor)) < 350) {
setMotorSpeed(motorGauche, VITESSE);
setMotorSpeed(motorDroit, -VITESSE);
}
stopRobot();
wait1Msec(500);
}

task main() {
resetGyro(gyroSensor);
wait1Msec(1000); // stabilisation

while (true) {
int couleur = getColorName(colorSensor);

// Si couleur JAUNE détectée : stop + rotation + arrêt final
if (couleur == colorYellow) {
stopRobot();
tourner360Degres();
stopRobot();
break;
}

// Détection d’obstacle
if (getUSDistance(sonarSensor) < DIST_OBSTACLE) {
stopRobot();
wait1Msec(500);

if (indexVirage < sizeof(virages) / sizeof(virages[0])) {
bool direction = virages[indexVirage];
tourner90Degres(direction);
indexVirage++;
}
} else {
avancer();
}

wait1Msec(50);
}

stopRobot(); // arrêt final
}
