#pragma config(Sensor, S1,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Sensor, S2,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S3,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S4,     contactSensor,  sensorEV3_Touch)
#pragma config(Motor,  motorA,          motorGauche,   tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorDroite,   tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int DIST_OBSTACLE = 15;
const int VITESSE = 50;

// Tableau des virages : false = gauche, true = droite
bool virages[] = {
false, // 1. gauche
true, // 2. droite
true, // 3. droite
true, // 4. droite
true, // 5. droite
false, // 6. gauche
true // 7. droite
};

int indexVirage = 0;
bool rougeD = false;

void avancer() {
setMotorSpeed(motorGauche, VITESSE);
setMotorSpeed(motorDroite, VITESSE);
}

void stopRobot() {
setMotorSpeed(motorGauche, 0);
setMotorSpeed(motorDroite, 0);
}

void tourner90Degres(bool droite) {
resetGyro(gyroSensor);
int angleCible = droite ? 75 : -75;

if (droite) {
while (getGyroDegrees(gyroSensor) < angleCible) {
setMotorSpeed(motorGauche, VITESSE);
setMotorSpeed(motorDroite, -VITESSE);
}
} else {
while (getGyroDegrees(gyroSensor) > angleCible) {
setMotorSpeed(motorGauche, -VITESSE);
setMotorSpeed(motorDroite, VITESSE);
}
}

stopRobot();
wait1Msec(500);
}

void tourner360Degres() {
resetGyro(gyroSensor);
while (abs(getGyroDegrees(gyroSensor)) < 350) {
setMotorSpeed(motorGauche, VITESSE);
setMotorSpeed(motorDroite, -VITESSE);
}
stopRobot();
wait1Msec(500);
}

void reculerDistanceCm(float cm) {
int temps = (int)(cm * 50); // ajuster le facteur selon vitesse réelle
setMotorSpeed(motorGauche, -VITESSE);
setMotorSpeed(motorDroite, -VITESSE);
wait1Msec(temps);
stopRobot();
wait1Msec(500);
}

void reculerJusquContact() {
setMotorSpeed(motorGauche, -VITESSE);
setMotorSpeed(motorDroite, -VITESSE);
while (!getTouchValue(contactSensor)) {
wait1Msec(10);
}
stopRobot();
}

task main() {
resetGyro(gyroSensor);
wait1Msec(1000); // stabilisation

while (true) {


// Couleur JAUNE : fin du programme
if (getColorName(colorSensor) == colorYellow) {
stopRobot();
tourner360Degres();
stopRobot();
break;
}

// Couleur ROUGE : comportement spécial, une seule fois
if (getColorName(colorSensor) == colorRed && !rougeD) {
rougeD = true;
stopRobot();
reculerDistanceCm(50); // 60 cm
tourner90Degres(false); // Tourne à droite

reculerJusquContact(); // Recul jusqu'à contact
playSound(soundBeepBeep); // Son
tourner90Degres(true); // Tourne à droite
continue; // Reprend programme
}

// Détection d?obstacle
if (getUSDistance(sonarSensor) < DIST_OBSTACLE) {
stopRobot();
wait1Msec(500);

if (indexVirage < sizeof(virages)/sizeof(virages[0])) {
bool direction = virages[indexVirage];
tourner90Degres(direction);
indexVirage++;
}
} else {
avancer();
}

wait1Msec(50);
}

stopRobot(); // arrêt final
}
